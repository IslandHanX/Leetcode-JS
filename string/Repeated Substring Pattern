/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
    if (s.length <= 1)
        return false;
    const t = (s + s).slice(1, -1);
    return t.includes(s);
};
/*
把字符串 s 看成长度为 n 的环。把 s 拼自己一次得到 s+s，比如：
s = "abab" → s+s = "abababab"
在 s+s 里，用长度 n 的滑动窗口从头到尾扫，会得到 所有“旋转版”的 s：
从偏移 0 取 n 个字符是原串 s
从偏移 1 取 n 个字符是把 s 向左转 1 位
…
从偏移 n-1 取 n 个字符是向左转 n-1 位
从偏移 n 取 n 个字符又是原串（在第二个 s 的开始）

👉 如果 s 是由某个更短子串 p 重复得到的（有周期 d = |p| < n），
那么把 s 旋转 d 位又会得到 s 本身。于是 s 会在 s+s 的“中间某个位置”
（偏移 d，满足 0 < d < n）再次出现。

为避免匹配到两端这两个“平凡位置”（偏移 0 和偏移 n 的原串），
我们把 s+s 的首尾各去掉 1 个字符：(s+s).slice(1, -1)。这样：

如果 s 有非平凡周期（可由更短子串重复），它会在“中间”出现 → includes 为 true

如果 s 没有非平凡周期，它只会在偏移 0 和 n 出现，这俩被切掉了 → includes 为 false
*/