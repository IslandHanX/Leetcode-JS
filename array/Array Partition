/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    nums.sort((a, b) => a - b);
    let sum = 0;
    for (let i = 0; i < nums.length; i += 2)
    {
        sum += nums[i];
    }
    return sum;
};
// 贪心 + 排序
/*
什么是贪心（Greedy）
在每一步都做当前看来最优的局部选择（不回退、不全局枚举），
期望得到全局最优解。能否正确，取决于问题是否具有贪心选择性质
（做了这个局部最优，仍然存在一个全局最优解包含它）。

解法：
把对象“可排序化”：想一个排序键（结束时间、价值密度、大小、deadline…）。
不确定用哪个键？先猜一个，用反例/交换论证检验；错误就换键。

证明正确性（至少给出直觉）
交换论证（Exchange Argument）：任意最优解都能通过“交换顺序/元素”变成包含你的贪心选择的解，且不变差。
例：活动选择按最早结束；若最优解第一个不是它，交换不劣。

Greedy stays ahead（领先不变式）：做了 k 步后，贪心方案的“前缀质量”不比任何解差。
Cut/Safe Property：像 MST，每次选的边对某个割都是最轻的，安全。

实现形态
排序 + 一次扫描（最常见）
优先队列/堆：动态地“每次拿当前最优”，如 Huffman、合并区间带淘汰、调度“保留最大的代价”等。
双指针：在排序后的数组两端/相邻移动，配对/匹配（分饼干、数组对和、区间覆盖）。
复杂度：通常 O(n log n)（因为排序），也有 O(n)（计数排序思路或单调结构）。
*/